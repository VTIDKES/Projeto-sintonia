<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Visual Blocks - Editor de Diagrama de Blocos</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root{
        --bg:#0f2b3a;
        --panel:#16384a;
        --panel2:#0b2230;
        --card:#f5f7fb;
        --accent:#22c55e;
        --warn:#f59e0b;
        --danger:#ef4444;
        --muted:#94a3b8;
      }
      html,body{height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;}
      .wrap{height:100%; display:flex; flex-direction:column;}
      .top{
        display:grid; grid-template-columns: 1.2fr 1fr 1fr;
        gap:10px; padding:10px; background:#ffffff;
      }
      .pill{
        border-radius:6px; padding:10px 12px; background:#eef6ff; color:#0f172a;
        display:flex; align-items:center; gap:8px; font-size:13px;
        border:1px solid #e5e7eb;
      }
      .pill.ok{background:#ecfdf5;}
      .pill .dot{width:8px; height:8px; border-radius:999px; background:#3b82f6;}
      .pill.ok .dot{background:var(--accent);}
      .bar{
        display:flex; gap:8px; padding:10px; background:#1f4b63; align-items:center; flex-wrap:wrap;
      }
      .btn{
        border:0; border-radius:8px; padding:7px 10px; font-size:12px; cursor:pointer;
        color:white; background:#2563eb;
        display:flex; align-items:center; gap:6px;
        user-select:none; white-space:nowrap;
      }
      .btn.orange{background:#f59e0b; color:#0f172a;}
      .btn.green{background:#22c55e; color:#0f172a;}
      .btn.purple{background:#a855f7;}
      .btn.red{background:#ef4444;}
      .btn.gray{background:#334155;}
      .btn.teal{background:#0d9488; color:white;}
      .btn:hover{opacity:0.85;}
      .content{flex:1; display:flex; min-height:0;}
      .canvasWrap{flex:1; position:relative; background:var(--bg); overflow:hidden;}
      .canvas{
        position:absolute; inset:0;
        background-image:
          linear-gradient(rgba(255,255,255,0.06) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255,255,255,0.06) 1px, transparent 1px);
        background-size: 24px 24px;
      }
      svg.wires{position:absolute; inset:0; pointer-events:none;}
      /* Standard block node */
      .node{
        position:absolute;
        width:160px; min-height:58px;
        border-radius:10px;
        background:#ffffff;
        box-shadow: 0 10px 25px rgba(0,0,0,0.25);
        border:1px solid rgba(15,23,42,0.15);
        overflow:visible;
      }
      .node .head{
        display:flex; align-items:center; justify-content:space-between;
        padding:8px 10px; background:#f1f5f9; font-size:12px; font-weight:650;
        border-radius:10px 10px 0 0;
      }
      .node .body{padding:8px 10px; font-size:12px; color:#0f172a;}
      .tag{font-size:11px; color:#334155; background:#e2e8f0; padding:2px 6px; border-radius:999px;}
      /* Input node */
      .node.type-input{
        background:#dcfce7; border-color:#22c55e;
        border-radius:20px; min-width:100px; width:120px;
      }
      .node.type-input .head{background:#bbf7d0; border-radius:20px 20px 0 0;}
      /* Output node */
      .node.type-output{
        background:#fee2e2; border-color:#ef4444;
        border-radius:20px; min-width:100px; width:120px;
      }
      .node.type-output .head{background:#fecaca; border-radius:20px 20px 0 0;}
      /* Summing junction */
      .node.type-sum{
        width:60px; min-height:60px; height:60px;
        border-radius:50%; background:#fef3c7; border:2px solid #f59e0b;
        display:flex; align-items:center; justify-content:center;
      }
      .node.type-sum .head{display:none;}
      .node.type-sum .body{
        padding:0; text-align:center; font-size:22px; font-weight:bold; color:#92400e;
      }
      /* Branch point */
      .node.type-branch{
        width:20px; min-height:20px; height:20px;
        border-radius:50%; background:#3b82f6; border:2px solid #1d4ed8;
        box-shadow: 0 4px 10px rgba(59,130,246,0.4);
      }
      .node.type-branch .head{display:none;}
      .node.type-branch .body{display:none;}
      /* Ports */
      .ports{position:absolute; inset:0; pointer-events:none;}
      .port{
        width:12px; height:12px; border-radius:999px;
        background:#0ea5e9; position:absolute; pointer-events:auto; cursor:crosshair;
        border:2px solid rgba(255,255,255,0.9);
        box-shadow:0 4px 10px rgba(0,0,0,0.25);
        z-index:10;
      }
      .port.out{background:#22c55e;}
      .port.in{background:#0ea5e9;}
      .port.active{background:#fbbf24; box-shadow:0 0 12px rgba(251,191,36,0.7);}
      .sign-label{
        position:absolute; font-size:10px; font-weight:700; color:#92400e;
        pointer-events:none; user-select:none;
      }
      .node.sel{outline:3px solid rgba(34,197,94,0.75);}
      .side{
        width:280px; background:#ffffff; border-left:1px solid #e5e7eb;
        padding:10px; display:flex; flex-direction:column; gap:10px;
        overflow-y:auto;
      }
      .card{border:1px solid #e5e7eb; border-radius:10px; padding:10px; background:#f8fafc;}
      .card h4{margin:0 0 8px 0; font-size:13px;}
      .kv{display:grid; grid-template-columns:1fr auto; gap:6px; font-size:12px;}
      .hint{font-size:12px; color:#334155; line-height:1.3;}
      .input{width:100%; padding:7px 8px; border-radius:8px; border:1px solid #cbd5e1; font-size:12px; box-sizing:border-box;}
      .small{font-size:11px; color:#475569;}
      .hr{height:1px; background:#e5e7eb; margin:8px 0;}
      .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:11px; padding:2px 6px; border:1px solid #cbd5e1; border-bottom-width:2px; border-radius:6px; background:white;}
      .sep{width:1px; height:28px; background:rgba(255,255,255,0.2); margin:0 4px;}
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="top">
        <div class="pill"><span class="dot"></span><strong>Editor Visual de Diagrama de Blocos</strong>&nbsp;<span class="small">Construa sistemas de controle visualmente</span></div>
        <div class="pill ok"><span class="dot"></span><strong>Blocos:</strong>&nbsp;<span id="countNodes">0</span></div>
        <div class="pill ok"><span class="dot"></span><strong>Conexoes:</strong>&nbsp;<span id="countEdges">0</span></div>
      </div>

      <div class="bar">
        <span class="small" style="color:#e2e8f0; font-weight:700; margin-right:4px;">SINAIS:</span>
        <button class="btn green" data-add="input">R(s) Entrada</button>
        <button class="btn red" data-add="output">Y(s) Saida</button>
        <button class="btn orange" data-add="sum">+/- Somador</button>
        <button class="btn teal" data-add="branch">* Ramificacao</button>

        <div class="sep"></div>
        <span class="small" style="color:#e2e8f0; font-weight:700; margin-right:4px;">BLOCOS:</span>
        <button class="btn" data-add="tf">G(s) Transferencia</button>
        <button class="btn orange" data-add="gain">K Ganho</button>
        <button class="btn purple" data-add="int">1/s Integrador</button>
        <button class="btn gray" data-add="der">s Derivador</button>
        <button class="btn purple" data-add="pid">PID</button>

        <div class="sep"></div>
        <span class="small" style="color:#e2e8f0; font-weight:700; margin-right:4px;">ACOES:</span>
        <button class="btn red" id="btnDelete">Deletar</button>
        <button class="btn gray" id="btnDuplicate">Duplicar</button>
        <button class="btn red" id="btnClear">Limpar</button>
        <button class="btn green" id="btnAuto">Auto-organizar</button>
      </div>

      <div class="content">
        <div class="canvasWrap" id="wrap">
          <div class="canvas" id="canvas"></div>
          <svg class="wires" id="wires"></svg>
        </div>

        <div class="side">
          <div class="card">
            <h4>Informacoes do Sistema</h4>
            <div class="kv"><div>Blocos:</div><div id="sideNodes">0</div></div>
            <div class="kv"><div>Conexoes:</div><div id="sideEdges">0</div></div>
            <div class="kv"><div>Selecionado:</div><div id="sideSel">Nenhum</div></div>
          </div>

          <div class="card">
            <h4>Parametros do bloco</h4>
            <div id="paramArea" class="hint">Selecione um bloco para editar.</div>
          </div>

          <div class="card">
            <h4>Dicas</h4>
            <div class="hint">
              <strong>Construir diagrama:</strong><br/>
              1. Adicione <span class="kbd">R(s) Entrada</span> e <span class="kbd">Y(s) Saida</span><br/>
              2. Adicione blocos (G(s), K, PID, etc.)<br/>
              3. Use <span class="kbd">Somador</span> para malha fechada<br/>
              4. Use <span class="kbd">Ramificacao</span> para dividir sinais<br/><br/>
              <strong>Conectar:</strong><br/>
              Clique no <span class="kbd" style="color:#22c55e;">ponto verde</span> (saida) e depois no <span class="kbd" style="color:#0ea5e9;">ponto azul</span> (entrada)<br/><br/>
              <strong>Atalhos:</strong><br/>
              <span class="kbd">Del</span> remove selecionado<br/>
              <span class="kbd">Ctrl+D</span> duplica selecionado
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://unpkg.com/streamlit-component-lib/dist/streamlit-component-lib.js"></script>
    <script>
      const wrap = document.getElementById("wrap");
      const canvas = document.getElementById("canvas");
      const wires = document.getElementById("wires");
      const countNodes = document.getElementById("countNodes");
      const countEdges = document.getElementById("countEdges");
      const sideNodes = document.getElementById("sideNodes");
      const sideEdges = document.getElementById("sideEdges");
      const sideSel = document.getElementById("sideSel");
      const paramArea = document.getElementById("paramArea");

      let model = {nodes: [], edges: []};
      let selId = null;
      let drag = null;
      let connectFrom = null;

      const randId = (p)=> p + "_" + Math.random().toString(16).slice(2) + Date.now().toString(16);

      /* ---------- Block type configuration ---------- */

      function nodeTitle(type){
        if(type==="tf") return "G(s)";
        if(type==="sum") return "\u03A3";
        if(type==="gain") return "K";
        if(type==="int") return "1/s";
        if(type==="der") return "s";
        if(type==="sat") return "sat";
        if(type==="input") return "R(s)";
        if(type==="output") return "Y(s)";
        if(type==="branch") return "";
        if(type==="pid") return "PID";
        return type;
      }

      function defaultParams(type){
        if(type==="tf") return {num:"1", den:"s+1"};
        if(type==="gain") return {k:"1"};
        if(type==="sum") return {signs:"+ -"};
        if(type==="int") return {};
        if(type==="der") return {};
        if(type==="sat") return {min:"-1", max:"1"};
        if(type==="input") return {label:"R(s)"};
        if(type==="output") return {label:"Y(s)"};
        if(type==="branch") return {};
        if(type==="pid") return {kp:"1", ki:"0", kd:"0"};
        return {};
      }

      /* Returns port definitions for a node type:
         {in: [{id:"in0", x, y}, ...], out: [{id:"out0", x, y}, ...]}
         x,y are relative to the node element (in pixels or % offsets).
         We compute actual pixel positions at render time based on element size. */
      function getPortConfig(type, params){
        if(type==="input"){
          return {in:[], out:[{id:"out0"}]};
        }
        if(type==="output"){
          return {in:[{id:"in0"}], out:[]};
        }
        if(type==="branch"){
          return {in:[{id:"in0"}], out:[{id:"out0"}, {id:"out1"}]};
        }
        if(type==="sum"){
          const signs = (params && params.signs) ? params.signs.trim().split(/\s+/) : ["+", "-"];
          const ins = signs.map((s, i) => ({id:"in"+i, sign:s}));
          return {in: ins, out:[{id:"out0"}]};
        }
        // Default: 1 in, 1 out
        return {in:[{id:"in0"}], out:[{id:"out0"}]};
      }

      /* ---------- Counter & selection ---------- */

      function updateCounters(){
        countNodes.textContent = model.nodes.length;
        countEdges.textContent = model.edges.length;
        sideNodes.textContent = model.nodes.length;
        sideEdges.textContent = model.edges.length;
        sideSel.textContent = selId ? (model.nodes.find(n=>n.id===selId)?.label || selId) : "Nenhum";
      }

      function setSel(id){
        selId = id;
        document.querySelectorAll(".node").forEach(el=>{
          el.classList.toggle("sel", el.dataset.id===id);
        });
        renderParams();
        updateCounters();
      }

      /* ---------- Node CRUD ---------- */

      function addNode(type){
        const r = wrap.getBoundingClientRect();
        const n = {
          id: randId("n"),
          type,
          label: nodeTitle(type),
          x: Math.max(20, r.width*0.15 + Math.random()*120),
          y: Math.max(30, r.height*0.2 + Math.random()*100),
          params: defaultParams(type),
        };
        model.nodes.push(n);
        render();
        setSel(n.id);
        pushToStreamlit();
      }

      function removeSelected(){
        if(!selId) return;
        model.edges = model.edges.filter(e => e.src!==selId && e.dst!==selId);
        model.nodes = model.nodes.filter(n=>n.id!==selId);
        selId = null;
        render();
        pushToStreamlit();
      }

      function duplicateSelected(){
        if(!selId) return;
        const n0 = model.nodes.find(n=>n.id===selId);
        if(!n0) return;
        const n = {...n0, id: randId("n"), x:n0.x+30, y:n0.y+30, params: {...n0.params}};
        model.nodes.push(n);
        render();
        setSel(n.id);
        pushToStreamlit();
      }

      function clearAll(){
        model = {nodes: [], edges: []};
        selId = null;
        connectFrom = null;
        render();
        pushToStreamlit();
      }

      function autoArrange(){
        // Simple left-to-right arrangement
        const typeOrder = {input:0, sum:1, tf:2, gain:2, int:2, der:2, pid:2, sat:2, branch:3, output:4};
        const sorted = [...model.nodes].sort((a,b) => (typeOrder[a.type]||2) - (typeOrder[b.type]||2));
        const marginX = 60, marginY = 80, stepX = 200, stepY = 120;
        let col = 0, row = 0, lastOrder = -1;
        sorted.forEach((ns,i)=>{
          const order = typeOrder[ns.type]||2;
          if(order !== lastOrder && i > 0){ col++; row = 0; }
          else if(i > 0){ row++; }
          lastOrder = order;
          const real = model.nodes.find(n=>n.id===ns.id);
          if(real){
            real.x = marginX + col * stepX;
            real.y = marginY + row * stepY;
          }
        });
        render();
        pushToStreamlit();
      }

      /* ---------- Edges / connections ---------- */

      function edgeExists(src, dst, srcPort, dstPort){
        return model.edges.some(e => e.src===src && e.dst===dst && e.srcPort===srcPort && e.dstPort===dstPort);
      }

      function connect(srcId, srcPort, dstId, dstPort){
        if(srcId===dstId) return;
        if(edgeExists(srcId, dstId, srcPort, dstPort)) return;
        model.edges.push({id: randId("e"), src: srcId, srcPort: srcPort, dst: dstId, dstPort: dstPort});
        connectFrom = null;
        clearPortHighlights();
        render();
        pushToStreamlit();
      }

      function clearPortHighlights(){
        document.querySelectorAll(".port.active").forEach(p=>p.classList.remove("active"));
      }

      /* ---------- Port position calculation ---------- */

      function getPortPos(nodeId, portId){
        const nodeEl = document.querySelector(`.node[data-id="${nodeId}"]`);
        if(!nodeEl) return {x:0,y:0};
        const portEl = nodeEl.querySelector(`.port[data-port="${portId}"]`);
        if(!portEl) {
          // Fallback to first matching type
          const isOut = portId.startsWith("out");
          const fallback = nodeEl.querySelector(`.port.${isOut?"out":"in"}`);
          if(!fallback) return {x:0,y:0};
          const r = fallback.getBoundingClientRect();
          const rw = wrap.getBoundingClientRect();
          return {x: r.left - rw.left + r.width/2, y: r.top - rw.top + r.height/2};
        }
        const r = portEl.getBoundingClientRect();
        const rw = wrap.getBoundingClientRect();
        return {x: r.left - rw.left + r.width/2, y: r.top - rw.top + r.height/2};
      }

      /* ---------- Wire rendering ---------- */

      function renderWires(){
        while(wires.firstChild) wires.removeChild(wires.firstChild);
        const rw = wrap.getBoundingClientRect();
        wires.setAttribute("width", rw.width);
        wires.setAttribute("height", rw.height);

        // Arrow marker
        const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
        const marker = document.createElementNS("http://www.w3.org/2000/svg","marker");
        marker.setAttribute("id","arrowhead");
        marker.setAttribute("markerWidth","10");
        marker.setAttribute("markerHeight","8");
        marker.setAttribute("refX","9");
        marker.setAttribute("refY","4");
        marker.setAttribute("orient","auto");
        const poly = document.createElementNS("http://www.w3.org/2000/svg","polygon");
        poly.setAttribute("points","0 0, 10 4, 0 8");
        poly.setAttribute("fill","rgba(34,197,94,0.9)");
        marker.appendChild(poly);
        defs.appendChild(marker);
        wires.appendChild(defs);

        model.edges.forEach(e=>{
          const a = getPortPos(e.src, e.srcPort || "out0");
          const b = getPortPos(e.dst, e.dstPort || "in0");
          if(a.x===0 && a.y===0) return;
          if(b.x===0 && b.y===0) return;

          const dx = Math.max(40, Math.abs(b.x - a.x) * 0.45);
          const c1 = {x: a.x + dx, y: a.y};
          const c2 = {x: b.x - dx, y: b.y};

          const path = document.createElementNS("http://www.w3.org/2000/svg","path");
          const d = `M ${a.x} ${a.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${b.x} ${b.y}`;
          path.setAttribute("d", d);
          path.setAttribute("fill","none");
          path.setAttribute("stroke","rgba(34,197,94,0.85)");
          path.setAttribute("stroke-width","3");
          path.setAttribute("stroke-linecap","round");
          path.setAttribute("marker-end","url(#arrowhead)");
          wires.appendChild(path);
        });
      }

      /* ---------- Parameter panel ---------- */

      function renderParams(){
        if(!selId){
          paramArea.innerHTML = `<div class="hint">Selecione um bloco para editar.</div>`;
          return;
        }
        const n = model.nodes.find(n=>n.id===selId);
        if(!n){
          paramArea.innerHTML = `<div class="hint">Selecione um bloco para editar.</div>`;
          return;
        }

        function inputRow(label, key, value){
          return `
            <div style="margin-bottom:8px;">
              <div class="small" style="margin-bottom:4px;">${label}</div>
              <input class="input" data-param="${key}" value="${String(value ?? "")}"/>
            </div>
          `;
        }

        let html = `<div class="small">Tipo: <strong>${n.type.toUpperCase()}</strong> | ID: ${n.id.slice(0,8)}</div><div class="hr"></div>`;

        if(n.type==="tf"){
          html += inputRow("Numerador (em s)", "num", n.params.num);
          html += inputRow("Denominador (em s)", "den", n.params.den);
        }else if(n.type==="gain"){
          html += inputRow("Ganho K", "k", n.params.k);
        }else if(n.type==="sum"){
          html += inputRow("Sinais (ex: + - ou + +)", "signs", n.params.signs);
          html += `<div class="small" style="margin-top:4px;">Cada sinal corresponde a uma porta de entrada. Ex: "+" "-" = 2 entradas, a primeira soma e a segunda subtrai.</div>`;
        }else if(n.type==="pid"){
          html += inputRow("Kp (proporcional)", "kp", n.params.kp);
          html += inputRow("Ki (integral)", "ki", n.params.ki);
          html += inputRow("Kd (derivativo)", "kd", n.params.kd);
        }else if(n.type==="input"){
          html += inputRow("Label", "label", n.params.label);
        }else if(n.type==="output"){
          html += inputRow("Label", "label", n.params.label);
        }else if(n.type==="sat"){
          html += inputRow("Min", "min", n.params.min);
          html += inputRow("Max", "max", n.params.max);
        }else{
          html += `<div class="hint">Sem parametros para este bloco.</div>`;
        }

        paramArea.innerHTML = html;

        paramArea.querySelectorAll("input[data-param]").forEach(inp=>{
          inp.addEventListener("input", (ev)=>{
            const k = ev.target.getAttribute("data-param");
            n.params[k] = ev.target.value;
            // Re-render if signs changed (affects port count)
            if(k === "signs"){
              render();
            } else {
              // Update body text
              const nodeEl = document.querySelector(`.node[data-id="${n.id}"]`);
              if(nodeEl){
                const bodyEl = nodeEl.querySelector(".body");
                if(bodyEl) bodyEl.textContent = getBodyText(n);
              }
            }
            pushToStreamlitDebounced();
          });
        });
      }

      function getBodyText(n){
        if(n.type==="tf") return `${n.params.num || "1"} / ${n.params.den || "1"}`;
        if(n.type==="gain") return `K = ${n.params.k || "1"}`;
        if(n.type==="pid") return `Kp=${n.params.kp||0} Ki=${n.params.ki||0} Kd=${n.params.kd||0}`;
        if(n.type==="input") return n.params.label || "R(s)";
        if(n.type==="output") return n.params.label || "Y(s)";
        if(n.type==="sum") return "\u03A3";
        if(n.type==="int") return "1/s";
        if(n.type==="der") return "s";
        return "";
      }

      /* ---------- Main render ---------- */

      function render(){
        canvas.querySelectorAll(".node").forEach(el=>el.remove());

        model.nodes.forEach(n=>{
          const el = document.createElement("div");
          el.className = `node type-${n.type}`;
          el.dataset.id = n.id;
          el.style.left = `${n.x}px`;
          el.style.top  = `${n.y}px`;

          const bodyText = getBodyText(n);
          const pc = getPortConfig(n.type, n.params);

          // Build inner HTML based on type
          if(n.type === "sum"){
            el.innerHTML = `<div class="body">\u03A3</div><div class="ports"></div>`;
          } else if(n.type === "branch"){
            el.innerHTML = `<div class="ports"></div>`;
          } else {
            el.innerHTML = `
              <div class="head">
                <span>${n.label}</span>
                <span class="tag">${n.type}</span>
              </div>
              <div class="body">${bodyText}</div>
              <div class="ports"></div>
            `;
          }

          canvas.appendChild(el);

          // Render ports after element is in DOM so we can use its dimensions
          const portsContainer = el.querySelector(".ports");
          if(!portsContainer){
            // For branch, create ports directly on node
          }

          // Input ports
          pc.in.forEach((p, idx) => {
            const portEl = document.createElement("div");
            portEl.className = "port in";
            portEl.dataset.port = p.id;
            portEl.dataset.node = n.id;
            portEl.dataset.kind = "in";
            portEl.title = `Entrada ${p.sign || idx}`;

            if(n.type === "sum"){
              // Position multiple inputs vertically on left side
              const totalIn = pc.in.length;
              const spacing = 50 / (totalIn + 1);
              const topPct = (spacing * (idx + 1));
              portEl.style.left = "-8px";
              portEl.style.top = `${topPct}px`;
              portEl.style.position = "absolute";

              // Sign label
              if(p.sign){
                const signEl = document.createElement("div");
                signEl.className = "sign-label";
                signEl.textContent = p.sign;
                signEl.style.left = "-20px";
                signEl.style.top = `${topPct - 5}px`;
                signEl.style.position = "absolute";
                el.appendChild(signEl);
              }
            } else if(n.type === "branch"){
              portEl.style.left = "-8px";
              portEl.style.top = "50%";
              portEl.style.transform = "translateY(-50%)";
              portEl.style.position = "absolute";
            } else {
              portEl.style.left = "-8px";
              portEl.style.top = "50%";
              portEl.style.transform = "translateY(-50%)";
              portEl.style.position = "absolute";
            }

            el.appendChild(portEl);

            portEl.addEventListener("mousedown",(ev)=>{
              ev.stopPropagation();
              setSel(n.id);
              if(connectFrom && connectFrom.kind==="out"){
                connect(connectFrom.nodeId, connectFrom.portId, n.id, p.id);
              } else {
                // Start connection from input (will need an output click next)
                connectFrom = {nodeId: n.id, portId: p.id, kind:"in"};
                portEl.classList.add("active");
              }
            });
          });

          // Output ports
          pc.out.forEach((p, idx) => {
            const portEl = document.createElement("div");
            portEl.className = "port out";
            portEl.dataset.port = p.id;
            portEl.dataset.node = n.id;
            portEl.dataset.kind = "out";
            portEl.title = `Saida ${idx}`;

            if(n.type === "branch"){
              if(idx === 0){
                portEl.style.right = "-8px";
                portEl.style.top = "50%";
                portEl.style.transform = "translateY(-50%)";
              } else {
                portEl.style.left = "50%";
                portEl.style.bottom = "-8px";
                portEl.style.transform = "translateX(-50%)";
              }
              portEl.style.position = "absolute";
            } else if(n.type === "sum"){
              portEl.style.right = "-8px";
              portEl.style.top = "50%";
              portEl.style.transform = "translateY(-50%)";
              portEl.style.position = "absolute";
            } else {
              portEl.style.right = "-8px";
              portEl.style.top = "50%";
              portEl.style.transform = "translateY(-50%)";
              portEl.style.position = "absolute";
            }

            el.appendChild(portEl);

            portEl.addEventListener("mousedown",(ev)=>{
              ev.stopPropagation();
              setSel(n.id);
              if(connectFrom && connectFrom.kind==="in"){
                connect(n.id, p.id, connectFrom.nodeId, connectFrom.portId);
              } else {
                connectFrom = {nodeId: n.id, portId: p.id, kind:"out"};
                portEl.classList.add("active");
              }
            });
          });

          // Drag
          el.addEventListener("mousedown",(ev)=>{
            if(ev.target.classList.contains("port")) return;
            setSel(n.id);
            const rect = el.getBoundingClientRect();
            drag = {id:n.id, dx: ev.clientX - rect.left, dy: ev.clientY - rect.top};
          });
        });

        document.querySelectorAll(".node").forEach(el=>{
          el.classList.toggle("sel", el.dataset.id===selId);
        });

        updateCounters();
        renderWires();
        renderParams();
      }

      /* ---------- Mouse events ---------- */

      window.addEventListener("mousemove",(ev)=>{
        if(!drag) return;
        const n = model.nodes.find(n=>n.id===drag.id);
        if(!n) return;
        const rw = wrap.getBoundingClientRect();
        n.x = Math.max(10, Math.min(rw.width-40, ev.clientX - rw.left - drag.dx));
        n.y = Math.max(10, Math.min(rw.height-40, ev.clientY - rw.top - drag.dy));
        const el = document.querySelector(`.node[data-id="${n.id}"]`);
        if(el){
          el.style.left = `${n.x}px`;
          el.style.top  = `${n.y}px`;
        }
        renderWires();
      });

      window.addEventListener("mouseup", ()=>{
        if(drag){
          drag = null;
          pushToStreamlit();
        }
      });

      // Click on empty canvas cancels connection
      canvas.addEventListener("mousedown",(ev)=>{
        if(ev.target === canvas){
          if(connectFrom){
            connectFrom = null;
            clearPortHighlights();
          }
          setSel(null);
        }
      });

      window.addEventListener("keydown",(ev)=>{
        // Don't capture if focus is in an input field
        if(ev.target.tagName === "INPUT") return;
        if(ev.key==="Delete" || ev.key==="Backspace") removeSelected();
        if(ev.ctrlKey && (ev.key==="d" || ev.key==="D")){
          ev.preventDefault();
          duplicateSelected();
        }
      });

      /* ---------- Toolbar buttons ---------- */

      document.querySelectorAll("button[data-add]").forEach(btn=>{
        btn.addEventListener("click", ()=> addNode(btn.getAttribute("data-add")));
      });
      document.getElementById("btnDelete").addEventListener("click", removeSelected);
      document.getElementById("btnDuplicate").addEventListener("click", duplicateSelected);
      document.getElementById("btnClear").addEventListener("click", clearAll);
      document.getElementById("btnAuto").addEventListener("click", autoArrange);

      /* ---------- Streamlit communication ---------- */

      let sendTimer = null;
      function pushToStreamlit(){
        if(window.Streamlit){
          window.Streamlit.setComponentValue(JSON.stringify(model));
          window.Streamlit.setFrameHeight(document.body.scrollHeight);
        }
      }
      function pushToStreamlitDebounced(){
        clearTimeout(sendTimer);
        sendTimer = setTimeout(pushToStreamlit, 250);
      }

      function onRender(event){
        const data = event.detail.args || {};
        try{
          const incoming = JSON.parse(data.model || "{}");
          if(incoming && incoming.nodes && incoming.edges){
            model = incoming;
          }
        }catch(err){}
        render();
        pushToStreamlit();
      }

      window.Streamlit.events.addEventListener(window.Streamlit.RENDER_EVENT, onRender);
      window.Streamlit.setComponentReady();
      window.Streamlit.setFrameHeight(document.body.scrollHeight);

      new ResizeObserver(()=>{ renderWires(); window.Streamlit.setFrameHeight(document.body.scrollHeight); }).observe(wrap);
    </script>
  </body>
</html>
